/* Copyright 2018  Peter Lund <firefly@vax64.dk>\

   Licensed under GPL v2.

   ---

   Test bench for autogenerated operand handling for asm/dis/sim

 */

#include <assert.h>
#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/stat.h>
#include <sys/types.h>

#include "shared.h"

//#include "vax-ucode.h"

#include "big-int.h"


/* worst-case is octo/h immediate operands: 1 opspec + 16 data bytes */
#define MAX_OPLEN	17

enum vax_format { FMT_VAX, FMT_SANE };
enum ifp	{ IFP_INT, IFP_F, IFP_D, IFP_G, IFP_H };


struct fields {
	int		Rn, Rx;
	int32_t		addr;
	int32_t		disp;

	struct big_int	imm;
	int8_t		lit6;
};


/* operand class

   IMM/REG/ADDR

   anything >= 0 is interpreted as ADDR class (where the actual value is the
   microcode address).
 */
#define CLASS_IMM	-2
#define CLASS_REG	-1


/* string buffer types */
typedef char disstr[100];
typedef char dis_part_str[50];


#include "op-support.h"

struct {
	int		no;
	const char	name[5];
} regs[] = {
	/* preferred names first */
	{12, "ap"},
	{13, "fp"},
	{14, "sp"},
	{15, "pc"},

	{ 0, "r0"},
	{ 1, "r1"},
	{ 2, "r2"},
	{ 3, "r3"},
	{ 4, "r4"},
	{ 5, "r5"},
	{ 6, "r6"},
	{ 7, "r7"},
	{ 8, "r8"},
	{ 9, "r9"},
	{10, "r10"},
	{11, "r11"},
	{12, "r12"},
	{13, "r13"},
	{14, "r14"},
	{15, "r15"},
};



/* asm */
static bool parse_reg(int *reg, int width, enum ifp ifp)
{
	(void) width, (void) ifp;

	parse_skipws();
	if (!parse_ok)
		return false;

	for (unsigned i=0; i < ARRAY_SIZE(regs); i++) {
		parse_begin();
		if (parse_symbol(regs[i].name)) {
			parse_commit();
			*reg = regs[i].no;
			return true;
		} else {
			parse_rollback();
		}
	}
	return true;
}

static bool parse_width(int width)
{
	/* don't call parse_skipws() -- it's up to the pattern in
	   operands.spec to decide whether to allow whitespace before
	   parse_width() or not.

           parse_ch() don't implicitly skip whitespace.
	 */
	switch (width) {
	case  1: return parse_ch('1');
	case  2: return parse_ch('2');
	case  4: return parse_ch('4');
	case  8: return parse_ch('8');
	case 16: return parse_ch('1') && parse_ch('6');
	default:
		assert(0);
	}
}

static unsigned fromhex(char ch)
{
	if     ((ch >= '0') && (ch <= '9'))
		return ch-'0';
	else if ((ch >= 'A') && (ch <= 'F'))
		return ch - 'A' + 10;
	else if ((ch >= 'a') && (ch <= 'f'))
		return ch - 'a' + 10;

	assert(0);
}


static bool parse_bigint(struct big_int *x, int width)
{
	/* [+-][0-9][0-9_]*
	   0x[0-9A-Fa-f][0-9A-Fa-f_]*
	 */

	struct big_int	tmp = {};
	bool		neg = false;
	char		ch;

	parse_skipws();

	/* decimal? */
	if (!parse_ok)
		return false;

	parse_begin();

	parse_begin();
	if (parse_oneof_ch("+-", &ch)) {
		parse_commit();
		neg = (ch == '-');
	} else {
		parse_rollback();
	}

	/* hex? */
	if (!parse_symbol("0x")) {
		parse_rollback();
		goto try_dec;
	}
	if (!parse_oneof_ch("0123456789ABCDEFabcdef", &ch)) {
		parse_rollback();
		return false;
	}

	tmp = (struct big_int) {.val[0] = fromhex(ch)};
	while (parse_oneof_ch("0123456789ABCDEFabcdef_", &ch)) {
		if (ch == '_')
			continue;

		if ((tmp.val[3] >> 24) != 0) {
			/* overflow */
			parse_rollback();
			return false;
		}

		tmp = big_add(big_shl(tmp, 4), (struct big_int) {.val[0] = fromhex(ch)}, NULL);
	}


try_dec:

	if (!parse_oneof_ch("0123456789", &ch)) {
		parse_rollback();
		goto try_hex;
	}


	/* FIXME: begin/rollback/commit should be around parse_oneof() */
	tmp = (struct big_int) {.val[0] = ch - '0'};
	while (parse_oneof_ch("0123456789_", &ch)) {
		if (ch == '_')
			continue;

		struct big_int	x10, x10ch;
		bool		ovf;

		x10 = big_shortmul(tmp, 10, &ovf);
		if (ovf) {
			... error
			parse_rollback()?
			return false;
		}

		x10ch = big_add(x10, (struct big_int) {.val[0]= ch - '0'}, &ovf);
		if (ovf) {
			... error
			parse_rollback()?
			return false;
		}
		tmp = x10ch;
	}

	parse_commit();

	*x = tmp;
	return true;
}


static bool parse_imm(struct big_int *imm, int width, enum ifp ifp)
{
	switch (ifp) {
	case IFP_INT:
		{
		struct big_int	x;

		if (!parse_bigint(&x, width))
			return false;

		*imm = x;
		return true;
		}
	case IFP_F:	return parse_fp(imm, 'f');
	case IFP_D:	return parse_fp(imm, 'd');
	case IFP_G:	return parse_fp(imm, 'g');
	case IFP_H:	return parse_fp(imm, 'h');
	default:
		assert(0);
	}
}


static bool parse_lit6(int8_t *lit6, int width, enum ifp ifp)
{
	struct big_int	x;

	if (!parse_imm(&x, width, ifp))
		return false;

	/* check that the imm fits in a lit6, convert it if it does */
	switch (ifp) {
	case IFP_INT:
		switch (width) {
		case  1:
		case  2:
		case  4:
			if ((x.val[0] & ~0x3F) == 0)
				return false;
			*lit6 = x.val[0];
			return true;
		case  8:
			if (((x.val[0] & ~0x3F) == 0) || (x.val[1] != 0))
				return false;
			*lit6 = x.val[0];
			return true;
		case 16:
			if (((x.val[0] & ~0x3F) == 0) || (x.val[1] != 0) || (x.val[2] != 0) || (x.val[2] != 0))
				return false;
			*lit6 = x.val[0];
			return true;
		default:
			assert(0);
		}
		break;
	case IFP_F:
		if ((x.val[0] & ~0x3F0) != 0x00004000)
			return false;
		*lit6 = (x.val[0] >> 4) & 0x3F;
		return true;
	case IFP_D:
		if (((x.val[0] & ~0x3F0) != 0x00004000) || (x.val[1] != 0))
			return false;
		*lit6 = (x.val[0] >> 4) & 0x3F;
		return true;
	case IFP_G:
		if (((x.val[0] & ~0x3E0) != 0x00004000)|| (x.val[1] != 0))
			return false;
		*lit6 = (x.val[0] >> 1) & 0x3F;
		return true;
	case IFP_H:
		if (((x.val[0] & ~0xE0000007) != 0x00004000) || (x.val[1] != 0) || (x.val[2] != 0) || (x.val[3] != 0))
			return false;
		*lit6 = ((x.val[0] >> 3) & 0x7) | ((x.val[0] >> 26) & 0x38);
		return true;
	default:
		assert(0);
	}
}


static bool parse_disp(int32_t *disp, int width, enum ifp ifp)
{
	struct big_int	x;
	(void) ifp;

	if (!parse_bigint(&x, width))
		return false;

	*disp = x.val[0];
	return true;
}


static bool parse_addr(int32_t *addr, int width, enum ifp ifp)
{
	(void) width, (void) ifp;

	struct big_int	x;

	if (parse_bigint(&x, 4)) {
		*addr = x.val[0];
		return true;
	}
	return false;
}


/* dis */

/* immediate -- 1/2/4/8/16 bytes, may be b/w/l/q/o int or f/d/g/h fp */
static struct str_ret str_imm(struct big_int imm, int width, enum ifp ifp)
{
	struct str_ret	buf;

	switch (ifp) {
	case IFP_INT: if (width == 1) sprintf(buf.str, "0x%02X", imm.val[0] & 0xFF);
		 else if (width == 2) sprintf(buf.str, "0x%04X", imm.val[0] & 0xFFFF);
		 else if (width == 4) sprintf(buf.str, "0x%04X_%04X", SPLIT(imm.val[0]));
		 else if (width == 8) {
				      sprintf(buf.str, "0x%04X_%04X_%04X_%04X",
				      		SPLIT(imm.val[1]), SPLIT(imm.val[0]));
		 }
		 else if (width ==16) {
				      sprintf(buf.str, "0x%04X_%04X_%04X_%04X__%04X_%04X_%04X_%04X",
				      		SPLIT(imm.val[3]), SPLIT(imm.val[2]), SPLIT(imm.val[1]), SPLIT(imm.val[0]));
		 }
		 else assert(0);
		 break;
	case IFP_F: assert(width== 4); return str_fp(imm, 'f');
	case IFP_D: assert(width== 8); return str_fp(imm, 'd');
	case IFP_G: assert(width== 8); return str_fp(imm, 'g');
	case IFP_H: assert(width==16); return str_fp(imm, 'h');
	default:
		assert(0);
	}
	return buf;
}


/* register name (r0, r5, pc, ...) */
static struct str_ret str_reg(int reg, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) width, (void) ifp;

	assert((reg >= 0) && (reg <= 15));

	/* look for first matching register name */
	for (unsigned i=0; i < ARRAY_SIZE(regs); i++) {
		if (reg == regs[i].no) {
			strcpy(buf.str, regs[i].name);
			return buf;
		}
	}

	/* no match ?! */
	assert(0);
}


static struct str_ret str_addr(int32_t addr, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) width, (void) ifp;

	sprintf(buf.str, "0x%04X_%04X", SPLIT(addr));
	return buf;
}


static struct str_ret str_label(int32_t addr, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) width, (void) ifp;

	sprintf(buf.str, "0x%04X_%04X", SPLIT(addr));
	return buf;
}


static struct str_ret str_disp(int32_t disp, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) width, (void) ifp;

	sprintf(buf.str, "%d", disp);
	return buf;
}



#if 0
/* declare the functions as static so they can be fully inlined */
#  define STATIC static
#else
/* ... or not, so we can see what code they compile to */
#  define STATIC
#endif

#include "op-asm.h"
#include "op-dis.h"
#include "op-sim.h"
#include "op-val.h"


/***/


struct testcase {
	int	cnt;
	uint8_t	b[MAX_OPLEN];
	int	width;
	enum ifp ifp;
};

typedef struct testcase test;

/* common test cases */

test tests[] = {
	{.cnt=0, .width=1},
	{.cnt=1, .b={0x00}, .width=1},
	{.cnt=1, .b={0x01}, .width=1},
	{.cnt=1, .b={0x3F}, .width=1},
	{.cnt=1, .b={0x00}, .width=4, .ifp=IFP_F},
	{.cnt=1, .b={0x01}, .width=4, .ifp=IFP_F},
	{.cnt=1, .b={0x3F}, .width=4, .ifp=IFP_F},
	{.cnt=1, .b={0x00}, .width=8, .ifp=IFP_D},
	{.cnt=1, .b={0x01}, .width=8, .ifp=IFP_D},
	{.cnt=1, .b={0x3F}, .width=8, .ifp=IFP_D},
	{.cnt=1, .b={0x00}, .width=8, .ifp=IFP_G},
	{.cnt=1, .b={0x01}, .width=8, .ifp=IFP_G},
	{.cnt=1, .b={0x3F}, .width=8, .ifp=IFP_G},
	{.cnt=1, .b={0x50}, .width=4},
	{.cnt=1, .b={0x57}, .width=4},
	{.cnt=1, .b={0x5F}, .width=4},

	{.cnt=2, .b={0x43,0x67}, .width=8},
	{.cnt=2, .b={0x43,0x63}, .width=8},
	{.cnt=2, .b={0x43,0x6F}, .width=8},
	{.cnt=2, .b={0x4F,0x67}, .width=8},

	{.cnt=2, .b={0x8F,0x67}, .width=1},
	{.cnt=3, .b={0x8F,0x67,0x12}, .width=2},
	{.cnt=5, .b={0x8F,0x78,0x56,0x34,0x12}, .width=4},
	{.cnt=9, .b={0x8F,0xF0,0xDE,0xBC,0x9A,0x78,0x56,0x34,0x12}, .width=8},
};

/***/


#if 1
void test_asm()
{
	const char	*cases[] = {
	"r0", "fp", "[r6]", "[r2++]", "[--r7]",
	"r0", "fp", "(r6)", "(r2+)", "(-r7)",
	};

	uint8_t	b[MAX_OPLEN];
	int	bytes;

	parse_init(cases[0]);
	bytes = op_asm_sane(b, 1, IFP_INT);
	printf("bytes: %d\n", bytes);
	for (int i=0; i < bytes; i++) {
		printf("%02X ", b[i]);
	}
	printf("\n");
	parse_done();
}
#else
void test_asm()
{
}
#endif


#if 1
void dis_run(struct testcase test)
{
	char	buf[100];
	memset(buf, 0xFF, sizeof(buf));

	struct dis_ret dis_ret = op_dis_sane(test.b, test.width, test.ifp);

	for (int i=0; i < (int) sizeof(test.b); i++) {
		if (i < test.cnt)
			printf("%02X ", test.b[i]);
		else
			printf("   ");
	}

	printf("%2d ", test.width);
	switch (test.ifp) {
	case IFP_INT:	printf("  "); break;
	case IFP_F:	printf("f "); break;
	case IFP_D:	printf("d "); break;
	case IFP_G:	printf("g "); break;
	case IFP_H:	printf("h "); break;
	default:
		assert(0);
	}

	if (dis_ret.cnt == -1)
		printf("%-9s", "-");
	else {
		assert((dis_ret.cnt >= 1) && (dis_ret.cnt <= (int) sizeof(test.b)));

		for (int i=0; i < (int) sizeof(test.b); i++)
			printf("%c", (i < dis_ret.cnt) ? 'x' : ' ');
	}

	printf(" ");
	if (dis_ret.cnt != -1) {
		printf("%s", buf);
	} else {
		printf("-");
	}
	printf("\n");
}


void test_dis()
{
	printf("Disassembly\n");
	printf("-----------\n");
	for (unsigned i=0; i < ARRAY_SIZE(tests); i++)
		dis_run(tests[i]);

	printf("\n");
}
#else
void test_dis()
{
}
#endif


#if 1
void sim_run(struct testcase test)
{
	assert((test.cnt > 0) && (test.cnt <= (int) sizeof(test.b)));
	assert((test.width == 1) || (test.width == 2) || (test.width == 4) || (test.width == 8));

	struct fields	fields;
	memset(&fields, 0xFF, sizeof(fields));

	struct sim_ret sim_ret = op_sim(test.b, &fields, test.width, test.ifp);

	for (int i=0; i < (int) sizeof(test.b); i++) {
		if (i < test.cnt)
			printf("%02X ", test.b[i]);
		else
			printf("   ");
	}

	printf("%2d ", test.width);
	switch (test.ifp) {
	case IFP_INT:	printf("  "); break;
	case IFP_F:	printf("f "); break;
	case IFP_D:	printf("d "); break;
	case IFP_G:	printf("g "); break;
	case IFP_H:	printf("h "); break;
	default:
		assert(0);
	}

	if (sim_ret.cnt == -1)
		printf("%-9s", "-");
	else {
		assert((sim_ret.cnt >= 1) && (sim_ret.cnt <= (int) sizeof(test.b)));

		for (int i=0; i < (int) sizeof(test.b); i++)
			printf("%c", (i < sim_ret.cnt) ? 'x' : ' ');
	}
	printf(" ");
	if (sim_ret.cnt == -1)
		printf("(");
	else
		printf(" ");
	switch (sim_ret.cl) {
	case CLASS_IMM:	printf("I    "); break;
	case CLASS_REG: printf("R    "); break;
	default:
		printf("M:%-3d", sim_ret.cl);
	}
	printf(" ");

	if (sim_ret.cnt == -1)
		printf("  ");	/* reserved-addr-mode --> ignore fields */
	else {
		if (test.cnt != sim_ret.cnt)
			printf("! ");	/* didn't parse the expected number of bytes */
		else
			printf("  ");
	}

	/* fields */
	if (fields.Rn != -1)
		printf("Rn=%d ", fields.Rn);
	if (fields.Rx != -1)
		printf("Rx=%d ", fields.Rx);
	if (fields.addr != -1)
		printf("addr=%04X_%04X ", SPLIT(fields.addr));
	if ((fields.imm.val[0] != (uint32_t) -1) || (fields.imm.val[1] != (uint32_t) -1)) {
		printf("imm[0]=%04X_%04X ", SPLIT(fields.imm.val[0]));
		if (fields.imm.val[1] != (uint32_t) -1)
			printf("imm[1]=%04X_%04X ", SPLIT(fields.imm.val[1]));
	}
	if (fields.lit6 != -1)
		printf("lit6=%02X ", fields.lit6);
	if (sim_ret.cnt == -1)
		printf(")");

	printf("\n");
}


void test_sim()
{
	printf("Simulator\n");
	printf("---------\n");
	for (unsigned i=0; i < ARRAY_SIZE(tests); i++)
		sim_run(tests[i]);

	printf("\n");
}
#else
void test_sim()
{
}
#endif


/***/


unsigned from_hex_ch(char ch)
{
	if (isdigit(ch))
		return ch - '0';
	else
		return ch - 'A' + 10;
}


struct afl_input {
	int		width;
	enum ifp	ifp;
	int		cnt;
	uint8_t		b[MAX_OPLEN];
};


void dump_afl(struct afl_input afl)
{
	printf("%d bytes:", afl.cnt);
	for (int i=0; i < afl.cnt; i++) {
		printf(" %02X", afl.b[i]);
	}
	if (afl.cnt == 0)
		printf(" --\n");
	else
		printf("\n");
	printf("width: %d bytes ", afl.width);
	switch (afl.ifp) {
	case IFP_INT: printf("int"); break;
	case IFP_F:   printf("f");   break;
	case IFP_D:   printf("d");   break;
	case IFP_G:   printf("g");   break;
	case IFP_H:   printf("h");   break;
	default:
		assert(0);
	}
	printf("\n");
}


#if 0

/* Read a line that describes the input parameters to dis/sim/val decoders

   In case of an error in the input, exit but do not abort!  We don't want to
   tell AFL that it found a bug in the program!
 */
struct afl_input afl_input()
{
	struct afl_input	afl = {};

	printf("width ::= 1/2/4/8/16\n");
	printf("ifp   ::= I/F/D/G/H\n");
	printf("byte  ::= [0-9A-F][0-9A-F]\n");
	printf("\n");


	/* read from stdin to EOL or EOF */
	char	inputbuf[100];

	if (!fgets(inputbuf, sizeof(inputbuf), stdin)) {
		fprintf(stderr, "AFL mode, couldn't read from stdin.\n");
		exit(EXIT_SUCCESS);	/* ? */
	}

	/* parse input:

	   <width> <ifp> [<byte>]*

	   width ::= 1/2/4/8/16
	   ifp   ::= I/F/D/G/H
	   byte  ::= [0-9A-F][0-9A-F]
	 */

	parse_init(inputbuf);

	parse_begin();
	parse_int(&afl.width);
	if (!parse_ok) {
		fprintf(stderr, "AFL mode, expected 1/2/4/8/16 from stdin.\n");
		exit(EXIT_SUCCESS);	/* ? */
	}
	if ((afl.width != 1) && (afl.width != 2) && (afl.width != 4) && (afl.width != 8) && (afl.width != 16)) {
		fprintf(stderr, "AFL mode, expected 1/2/4/8/16 from stdin.\n");
		exit(EXIT_SUCCESS);	/* ? */
	}
	printf("width: %d\n", afl.width);


	char	ch;
	parse_skipws();
	if (!parse_oneof_ch("IFDGH", &ch)) {
		fprintf(stderr, "AFL mode, expected I/F/D/G/H from stdin.\n");
		exit(EXIT_SUCCESS);	/* ? */
	}
	switch (ch) {
	case 'I': afl.ifp = IFP_INT; break;
	case 'F': afl.ifp = IFP_F; break;
	case 'D': afl.ifp = IFP_D; break;
	case 'G': afl.ifp = IFP_G; break;
	case 'H': afl.ifp = IFP_H; break;
	default:
		assert(0);
	}
	printf("ifp: %d\n", (int) afl.ifp);

	/* check that width and ifp match */
	if (((afl.ifp == IFP_F) && (afl.width != 4)) ||
	    ((afl.ifp == IFP_D) && (afl.width != 8)) ||
	    ((afl.ifp == IFP_G) && (afl.width != 8)) ||
	    ((afl.ifp == IFP_H) && (afl.width != 16))) {
		fprintf(stderr, "AFL mode, ifp and width don't match.\n");
		exit(EXIT_SUCCESS);	/* ? */
	}

	parse_skipws();


	/* bytes in hex */
	while (afl.cnt < MAX_OPLEN) {
		parse_begin();
		parse_skipws();

		char	ch_hi, ch_lo;
		parse_oneof_ch("0123456789ABCDEF", &ch_hi);
		parse_oneof_ch("0123456789ABCDEF", &ch_lo);
		if (!parse_ok) {
			parse_rollback();
			break;
		}
		parse_commit();
		afl.b[afl.cnt] = (from_hex_ch(ch_hi) << 4) | from_hex_ch(ch_lo);
		afl.cnt++;
	}

	if (!parse_eof()) {
		fprintf(stderr, "AFL mode, garbage at end of line after the bytes.\n");
		exit(EXIT_SUCCESS);	/* ? */
	}

	return afl;
}



void afl_dis()
{
	struct afl_input afl;

	afl = afl_input();

//	dump_afl(afl);

	afl_dis_once(afl);
}



void afl_sim()
{
	struct afl_input afl;

	afl = afl_input();

//	dump_afl(afl);

	afl_sim_once(afl);
}


void afl_val()
{
	struct afl_input afl;

	afl = afl_input();

//	dump_afl(afl);

	if (op_val(afl.b, afl.width))
		printf("valid.\n");
	else
		printf("reserved addressing mode.\n");
}
#endif


/***/


struct afl_input afl_input_bin()
{
	struct afl_input	afl = {};

	afl.cnt = fread(afl.b, 1, MAX_OPLEN, stdin);

	afl.width = 1;
	afl.ifp   = IFP_INT;

	return afl;
}


/***/


void afl_asm()
{
}


void afl_dis_once(struct afl_input afl)
{
	char	buf[100];
	memset(buf, 0x0, sizeof(buf));

	struct dis_ret dis_ret = op_dis_sane(afl.b, afl.width, afl.ifp);
	if (dis_ret.cnt == -1) {
		printf("reserved addressing mode.\n");
		return;
	}

	if ((dis_ret.cnt <= 0) || (dis_ret.cnt > MAX_OPLEN)) {
		fprintf(stderr, "wrong no of bytes decoded: %d\n", dis_ret.cnt);
		abort();
	}
	if (dis_ret.cnt > afl.cnt) {
		fprintf(stderr, "redo with more bytes: %d/%d\n", dis_ret.cnt, afl.cnt);
		return;
	}

	/* dump info */
	printf("bytes decoded: %d/%d\n", dis_ret.cnt, afl.cnt);
	printf("op           : '%s'\n", buf);
}


void afl_dis()
{
	struct afl_input afl;

	afl = afl_input_bin();

//	dump_afl(afl);

	char	buf[100];
	memset(buf, 0x0, sizeof(buf));

	for (int width=0; width <= 4; width++) {
		afl.width = 1 << width;
		afl.ifp   = IFP_INT;
		afl_dis_once(afl);
	}
	afl.width = 4;
	afl.ifp   = IFP_F;
	afl_dis_once(afl);
	afl.width = 8;
	afl.ifp   = IFP_D;
	afl_dis_once(afl);
	afl.width = 8;
	afl.ifp   = IFP_G;
	afl_dis_once(afl);
	afl.width = 16;
	afl.ifp   = IFP_H;
	afl_dis_once(afl);
}


void afl_sim_once(struct afl_input afl)
{
	struct fields fields = {};
	memset(&fields, 0xFF, sizeof(fields));

	struct sim_ret sim_ret = op_sim(afl.b, &fields, afl.width, afl.ifp);
	if (sim_ret.cnt == -1) {
		printf("reserved addressing mode.\n");
		return;
	}

	if ((sim_ret.cnt <= 0) || (sim_ret.cnt > MAX_OPLEN)) {
		fprintf(stderr, "wrong no of bytes decoded: %d\n", sim_ret.cnt);
		abort();
	}

	if (sim_ret.cnt > afl.cnt) {
		fprintf(stderr, "redo with more bytes: %d/%d\n", sim_ret.cnt, afl.cnt);
		return;
	}

	/* dump info */
	printf("bytes decoded: %d/%d\n", sim_ret.cnt, afl.cnt);
	if (fields.Rn != -1)
		printf("Rn=%d ", fields.Rn);
	if (fields.Rx != -1)
		printf("Rx=%d ", fields.Rx);
	if (fields.addr != -1)
		printf("addr=%04X_%04X ", SPLIT(fields.addr));
	if ((fields.imm.val[0] != (uint32_t) -1) || (fields.imm.val[1] != (uint32_t) -1)) {
		printf("imm[0]=%04X_%04X ", SPLIT(fields.imm.val[0]));
		if (fields.imm.val[1] != (uint32_t) -1)
			printf("imm[1]=%04X_%04X ", SPLIT(fields.imm.val[1]));
	}
	if (fields.lit6 != -1)
		printf("lit6=%02X ", fields.lit6);
	printf("\n");
}


void afl_sim()
{
	struct afl_input afl;

	afl = afl_input_bin();

//	dump_afl(afl);

	for (int width=0; width <= 4; width++) {
		afl.width = 1 << width;
		afl.ifp   = IFP_INT;
		afl_sim_once(afl);
	}
	afl.width = 4;
	afl.ifp   = IFP_F;
	afl_sim_once(afl);
	afl.width = 8;
	afl.ifp   = IFP_D;
	afl_sim_once(afl);
	afl.width = 8;
	afl.ifp   = IFP_G;
	afl_sim_once(afl);
	afl.width = 16;
	afl.ifp   = IFP_H;
	afl_sim_once(afl);
}


void afl_val()
{
	struct afl_input afl;

	afl = afl_input_bin();

//	dump_afl(afl);

	for (int width=0; width <= 4; width++) {
		afl.width = 1 << width;
		if (op_val(afl.b, afl.width))
			printf("valid.\n");
		else
			printf("reserved addressing mode.\n");
	}
}


/***/

#define TEST_DIR	"afl/op-decode/"
#define TEST_DIR_ASM	"afl/op-asm/"

const char	*asm_tests[] = {
	"r0",  "r9", "r10", "r15",  "ap", "fp", "sp", "pc",
	" r0 ",  " r9 ", " r10 ", " r15 ", " ap ", " fp ", " sp ", " pc ",
	"[r0]", "[r9]", "[r10]", "[r15]", "[ap]", "[fp]", "[sp]", "[pc]",
	" [r0] ", " [r9] ", " [r10] ", " [r15] ", " [ap] ", " [fp] ", " [sp] ", " [pc] ",
	" [ r0 ] ", " [ r9 ] ", " [ r10 ] ", " [ r15 ] ", " [ ap ] ", " [ fp ] ", " [ sp ] ", " [ pc ] ",
};

void afl_output()
{
	/* the dumb output process automatically takes care of duplicates
	   because all but the last of them will be overwritten.
	 */

	/* create directory */
	mkdir("afl/", 0775);   /* ignore errors */
	mkdir(TEST_DIR, 0775); /* ignore errors -- it's fine if it exists */
	mkdir(TEST_DIR_ASM, 0775); /* ignore errors -- it's fine if it exists */


	/* create byte sequence files (decoder tests) */
	for (unsigned i=0; i < ARRAY_SIZE(tests); i++) {
		/* file name = hex bytes + '.auto' */
		char	fname[1000] = {};

		strcpy(fname, TEST_DIR);
		if (tests[i].cnt == 0) {
			sprintf(fname+strlen(fname), "zero-bytes");
		} else {
			for (int j=0; j < tests[i].cnt; j++) {
				assert(strlen(fname) + 100 < sizeof(fname));
				sprintf(fname+strlen(fname), "%02X", tests[i].b[j]);
			}
		}
		sprintf(fname+strlen(fname), ".auto");

		/* create file */
		printf("Writing to %s\n", fname);

		FILE	*f;
		if ((f = fopen(fname, "w")) == NULL) {
			perror("fopen");
			fprintf(stderr, "Can't write to '%s'.\n", fname);
			exit(1);
		}

		/* write */
		for (int j=0; j < tests[i].cnt; j++)
			fprintf(f, "%c", tests[i].b[j]);

		/* close */
		fclose(f);
	}


	/* create asm operand test files */
	for (unsigned i=0; i < ARRAY_SIZE(asm_tests); i++) {
		char	fname[1000] = {};

		strcpy(fname, TEST_DIR_ASM);
		sprintf(fname+strlen(fname), "%0u", i);

		/* create file */
		printf("Writing to %s\n", fname);

		FILE	*f;
		if ((f = fopen(fname, "w")) == NULL) {
			perror("fopen");
			fprintf(stderr, "Can't write to '%s'.\n", fname);
			exit(1);
		}

		/* write */
		fprintf(f, "%s", asm_tests[i]);

		/* close */
		fclose(f);
	}
}


/***/


void help()
{
	fprintf(stderr, "./test-op <mode>\n");
	fprintf(stderr, "\n");
	fprintf(stderr, " mode:\n");
	fprintf(stderr, "   --built-in    built-in test of asm/dis/sim\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "   --output      write tests cases to %s directory\n", TEST_DIR);
	fprintf(stderr, "   --test-asm    test asm with a line from stdin\n");
	fprintf(stderr, "   --test-dis    test asm with a byte sequence from stdin\n");
	fprintf(stderr, "   --test-sim    test sim with a byte sequence from stdin\n");
	fprintf(stderr, "   --test-val    test val with a byte sequence from stdin\n");
#if 0
	fprintf(stderr, "   --dis-bin     test asm with a byte sequence from stdin, raw bytes\n");
	fprintf(stderr, "   --sim-bin     test sim with a byte sequence from stdin, raw bytes\n");
	fprintf(stderr, "   --val-bin     test val with a byte sequence from stdin, raw bytes\n");
#endif
	fprintf(stderr, "\n");
	fprintf(stderr, " --test-(asm|dis|sim|val), --output are used for testing with American Fuzzy Lop.\n");
	exit(EXIT_FAILURE);
}


int main(int argc, char *argv[argc])
{
#ifdef __AFL_HAVE_MANUAL_CONTROL
	while (__AFL_LOOP(1000)) {
#endif
	if (argc != 2) {
		help();
	}

	if (strcmp(argv[1], "--built-in") == 0) {
		test_asm();
		test_dis();
		test_sim();
	} else if (strcmp(argv[1], "--test-asm") == 0) {
		afl_asm();
	} else if (strcmp(argv[1], "--test-dis") == 0) {
		afl_dis();
	} else if (strcmp(argv[1], "--test-sim") == 0) {
		afl_sim();
	} else if (strcmp(argv[1], "--test-val") == 0) {
		afl_val();
#if 0
	} else if (strcmp(argv[1], "--dis-bin") == 0) {
		afl_dis_bin();
	} else if (strcmp(argv[1], "--sim-bin") == 0) {
		afl_sim_bin();
	} else if (strcmp(argv[1], "--val-bin") == 0) {
		afl_val_bin();
#endif
	} else if (strcmp(argv[1], "--output") == 0) {
		afl_output();
	} else {
		help();
	}
#ifdef __AFL_HAVE_MANUAL_CONTROL
	}
#endif
	return EXIT_SUCCESS;
}

