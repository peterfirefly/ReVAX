#!/usr/bin/perl

# Copyright 2018  Peter Lund <firefly@vax64.dk>
#
# Licensed under GPL v2.
#
# ---
#
# Check for reserved identifers.
#
#   ctags misc/*.[ch] src/*.[ch] runtime/*.[ch] ods2/ods2-firefly.c
#   misc/check-reserved.pl tags
#
# It should work for tags files generated by either ctags, exuberant-ctags,
# or universal-ctags.
#
# Not all identifiers from all C99 headers are checked for -- some of the more
# obscure headers are ignored.
#
# The tests are overly conservative on purposes -- it is normally perfectly okay
# to define a function scope identifier that clashes with any of the reserved
# identifiers, except for _[A-Z_].  The ctags file tells us what kind of scope/
# namespace the identifier has so it wouldn't be hard to take that into account.
# There's just no need yet.

use strict;
use warnings;


###

# lists of identifers from various system headers.
#
# (Identifiers that are caught by regular expressions from C99 §7.1.3 or §7.26
# are not explicitly mentioned in these tables.)

# C99
my @assert	= ('assert');
my @ctype	= ();
my @errno	= ('errno');
my @float	= (# see C99 §5.2.4.2.2.
		   'FLT_ROUNDS', 'FLT_EVAL_METHOD', 'FLT_RADIX',
		   'FLT_MANT_DIG', 'DBL_MANT_DIG', 'LDBL_MANT_DIG', 'DECIMAL_DIG', 'FLT_DIG', 'DBL_DIG', 'LDBL_DIG',

		   'FLT_MIN_EXP'   , 'DBL_MIN_EXP'   , 'LDBL_MIN_EXP'   ,
		   'FLT_MIN_10_EXP', 'DBL_MIN_10_EXP', 'LDBL_MIN_10_EXP',
		   'FLT_MAX_EXP    ', 'DBL_MAX_EXP'  , 'LDBL_MAX_EXP'   ,
		   'FLT_MAX_10_EXP', 'DBL_MAX_10_EXP', 'LDBL_MAX_10_EXP',

		   'FLT_MAX', 'DBL_MAX', 'LDBL_MAX',

		   'FLT_EPSILON', 'DBL_EPSILON', 'LDBL_EPSILON',

		   'FLT_MIN', 'DBL_MIN', 'LDBL_MIN'
		   );
my @inttypes	= ('imaxdiv_t', 'imaxabs', 'imaxdiv', 'strtoimax', 'strtoumax', 'wcstoimax', 'wcstoumax');
my @limits	= (# see C99 §5.2.4.2.1.
		   'CHAR_BIT',
		   'SCHAR_MIN', 'SCHAR_MAX', 'UCHAR_MAX', 'CHAR_MIN',  'CHAR_MAX',
		   'MB_LEN_MAX',
		   'SHRT_MIN', 'SHRT_MAX', 'USHRT_MAX',
		   'INT_MIN', 'INT_MAX', 'UINT_MAX',
		   'LONG_MIN', 'LONG_MAX', 'ULONG_MAX',
		   'LLONG_MIN', 'LLONG_MAX', 'ULLONG_MAX'
		   );
my @locale	= ('lconv', 'setlocale', 'localeconv');
my @math	= (# 7.12
		   'float_t', 'double_t', 'HUGE_VAL', 'HUGE_VALF', 'HUGE_VALL',
		   'INFINITY', 'NAN',
		   'FP_INFINITE', 'FP_NAN', 'FP_NORMAL', 'FP_SUBNORMAL', 'FP_ZERO',
		   'FP_FAST_FMA', 'FP_FAST_FMAF', 'FP_FAST_FMAL',
		   'FP_ILOGB0', 'FP_ILOGBNAN',
		   'MATH_ERRNO', 'MATH_ERREXCEPT', 'math_errhandling',

		   # 7.12.3 Classification macros
		   'fpclassify', 'isfinite', 'isinf', 'isnan', 'isnormal', 'signbit',

		   # 7.12.4 Trigonometric functions
		   'acos' , 'asin' , 'atan' , 'atan2' , 'cos' , 'sin' , 'tan' ,
		   'acosf', 'asinf', 'atanf', 'atan2f', 'cosf', 'sinf', 'tanf',
		   'acosl', 'asinl', 'atanl', 'atan2l', 'cosl', 'sinl', 'tanl',

		   # 7.12.5 Hyperbolic functions
		   'acosh' , 'asinh' , 'atanh' , 'cosh' , 'sinh' , 'tanh' ,
		   'acoshf', 'asinhf', 'atanhf', 'coshf', 'sinhf', 'tanhf',
		   'acoshl', 'asinhl', 'atanhl', 'coshl', 'sinhl', 'tanhl',

		   # 7.12.6 Exponential and logarithmic functions
		   'exp' , 'exp2' , 'expm1' , 'frexp' , 'ilogb' , 'ldexp' , 'log' , 'log10' , 'log1p' , 'log2' , 'logb' , 'modf' , 'scalbn' , 'scalbln',
		   'expf', 'exp2f', 'expm1f', 'frexpf', 'ilogbf', 'ldexpf', 'logf', 'log10f', 'log1pf', 'log2f', 'logbf', 'modff', 'scalbnf', 'scalblnf',
		   'expl', 'exp2l', 'expm1l', 'frexpl', 'ilogbl', 'ldexpl', 'logl', 'log10l', 'log1pl', 'log2l', 'logbl', 'modfl', 'scalbnl', 'scalblnl',

		   # 7.12.7 Power and absolute-value functions
		   'cbrt' , 'fabs' , 'hypot' , 'pow' , 'sqrt' ,
		   'cbrtf', 'fabsf', 'hypotf', 'powf', 'sqrtf',
		   'cbrtl', 'fabsl', 'hypotl', 'powl', 'sqrtl',

		   # 7.12.8 Error and gamma functions
		   'erf' , 'erfc' , 'lgamma' , 'tgamma' ,
		   'erff', 'erfcf', 'lgammaf', 'tgammaf',
		   'erfl', 'erfcl', 'lgammal', 'tgammal',

		   # 7.12.9 Nearest integer functions
		   'ceil',  'floor',  'nearbyint',  'rint',  'lrint',  'llrint',  'round',  'lround',  'llround',  'trunc',
		   'ceilf', 'floorf', 'nearbyintf', 'rintf', 'lrintf', 'llrintf', 'roundf', 'lroundf', 'llroundf', 'truncf',
		   'ceill', 'floorl', 'nearbyintl', 'rintl', 'lrintl', 'llrintl', 'roundl', 'lroundl', 'llroundl', 'truncl',

		   # 7.12.10 Remainder functions
		   'fmod' , 'remainder' , 'remquo' ,
		   'fmodf', 'remainderf', 'remquof',
		   'fmodl', 'remainderl', 'remquol',

		   # 7.12.11 Manipulation functions
		   'copysign' , 'nan' , 'nextafter' , 'nexttoward' ,
		   'copysignf', 'nanf', 'nextafterf', 'nexttowardf',
		   'copysignl', 'nanl', 'nextafterl', 'nexttowardl',

		   # 7.12.12 Maximum, minimum, and positive difference functions
		   'fdim' , 'fmax' , 'fmin' ,
		   'fdimf', 'fmaxf', 'fminf',
		   'fdiml', 'fmaxl', 'fminl',

		   # 7.12.13 Floating multiply-add
		   'fma' ,
		   'fmaf',
		   'fmal',

		   # 7.12.14 Comparison macros
		   'isgreater', 'isgreaterequal', 'isless', 'islessequal', 'islessgreater', 'isunordered',
		   );
my @stdarg	= ('va_list', 'va_start', 'va_arg', 'va_copy', 'va_end');
my @stdbool	= ('bool', 'true', 'false');
my @stddef	= ('ptrdiff_t', 'size_t', 'wchar_t', 'NULL', 'offsetof');
my @stdint	= ();
my @stdio	= ('FILE', 'fpos_t', 'BUFSIZ', 'EOF',
		   'FOPEN_MAX', 'FILENAME_MAX', 'L_tmpnam', 'SEEK_CUR', 'SEEK_END', 'SEEK_SET',
		   'TMP_MAX',
		   'stderr', 'stdin', 'stdout',

		   # 7.19.4 Operations on files
		   'remove', 'rename', 'tmpfile', 'tmpnam',

		   # 7.19.5 File access functions
		   'fclose', 'fflush', 'fopen', 'freopen', 'setbuf', 'setvbuf',

		   # 7.19.6 Formatted input/output functions
		   'fprintf', 'fscanf', 'printf', 'scanf', 'snprintf', 'sprintf',
		   'sscanf', 'vfprintf', 'vfscanf', 'vprintf', 'vscanf', 'vsnprintf',
		   'vsprintf', 'vsscanf',

		   # 7.19.7 Character input/output functions
		   'fgetc', 'fgets', 'fputc', 'fputs', 'getc', 'getchar',
		   'gets', 'putc', 'putchar', 'puts', 'ungetc',

		   # 7.19.8 Direct input/output functions
		   'fread', 'fwrite',

		   # 7.19.9 File positioning functions
		   'fgetpos', 'fseek', 'fsetpos', 'ftell', 'rewind',

		   # 7.19.10 Error-handling functions
		   'clearerr', 'feof', 'ferror', 'perror'
		   );
my @stdlib	= ('size_t', 'wchar_t', 'div_t', 'ldiv_t', 'lldiv_t',
		   'EXIT_FAILURE', 'EXIT_SUCCESS',
		   'RAND_MAX',
		   'MB_CUR_MAX', 'MB_LEN_MAX',
		   'atof', 'atoi', 'atol', 'atoll',
		   'strtod', 'strtof', 'strtold',
		   'strtol', 'strtoll', 'stroul', 'strtoull',
		   'rand', 'srand',
		   'calloc', 'free', 'malloc', 'realloc',
		   'abort', 'atexit', 'exit',
		   'getenv',
		   'system',
		   'bsearch', 'qsort',
		   'abs', 'labs', 'llabs',
		   'div', 'ldiv', 'lldiv',
		   'mblen', 'mbtowc', 'wctomb', 'mbstowcs', 'wcstombs'
		   );
my @string	= ('size_t', 'NULL',
		   'memcpy', 'memmove', 'strcpy', 'strncpy',
		   'strcat', 'strncat',
		   'memcmp', 'strcmp', 'strcoll', 'strncmp', 'strxfrm',
		   'memchr', 'strchr', 'strcspn', 'strpbrk', 'strrchr', 'strspn', 'strstr', 'strtok',
		   'memset', 'strerror', 'strlen');
my @time	= ('CLOCKS_PER_SEC', 'clock_t', 'time_t', 'tm',
		   'clock', 'difftime', 'mktime', 'time',
		   'asctime', 'ctime', 'gmtime', 'localtime', 'strftime');

# POSIX
my @sys_stat	= ();


my @identifiers = (
	# C99 headers
	@assert, @ctype, @errno, @float, @limits, @inttypes, @locale, @math,
	@stdarg, @stdbool, @stddef, @stdint, @stdio, @stdlib,
	@string, @time,

	# POSIX
	@sys_stat
	);


sub checkid($) {
	my ($id) = @_;

	# The following patterns are taken from:
	#   C99 standard §7.1.3 Reserved identifiers
	return 0 if /^_[A-Z_]/;	# reserved for any use
	return 0 if /^_/;	# reserved for file scope
	return 0 if grep {$id eq $_}  @identifiers;

	# special-casing for stdint.h
	return 0 if /^(int|uint).*_t$/;
	return 0 if /^(INT|UINT).*(_MIN|_MAX|_C)$/;
	return 0 if /^(PTRDIFF|SIG_ATOMIC|SIZE|WCHAR|WINT)_(MIN|MAX)$/;

	# The following patterns are taken from:
	#   C99 standard §7.26  Future library directions

	# complex.h
	return 0 if /^(cerf|cexpm1|clog2|cerfc|clog10|clgamma|cexp2|clog1p|ctgamma)[fl]?/;

	# ctype.h
	return 0 if /^(is|to)[a-z]/;	# clashes w/ isbranch

	# errno.h
	return 0 if /^E[0-9A-Z]/;	# clashes w/ ELF_MAGIC

	# inttypes.h
	return 0 if /^(PRI|SCN)[a-zX]/;

	# locale.h
	return 0 if /^LC_[A-Z]/;

	# signal.h
	return 0 if /^(SIG|SIG_)[A-Z]/;

	# stdbool
	return 0 if /^(bool|true|false)$/;

	# stdint.h
	return 0 if /^(int|uint).*_t$/;
	return 0 if /^(INT|UINT).*(_MAX|_MIN|_C)$/;

	# stdlib.h
	return 0 if /^str[a-z]/;

	# string.h
	return 0 if /^(str|mem|wcs)[a-z]/;	# clashes w/ struct_regstr

	# otherwise it's probably ok
	return 1;
}


###

my $NORM = "\033[0m";
my $BOLD = "\033[31;1m";	# red background

while (<>) {
	chomp;

	next if /^!/;
	if (/^(\S+)[\t](.*?)[\t]/) {
		print "$BOLD$1$NORM in $2 is not an ok identifier for this project\n" if !checkid($1);
	}
}

