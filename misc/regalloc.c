/* Copyright 2018  Peter Lund <firefly@vax64.dk>

   Licensed under GPL v2.

   ---

   Analyze the instructions in vax-tables.h to see which registers they need
   for communication between the pre/exe/post phases.

   Also figure out anything else interesting that can be derived from vax-tables.h.
 */


#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "macros.h"
#include "vax-instr.h"


/* describes the register allocation for a single instruction.

   precnt is the total number of pre registers used
   execnt is the total number of exe registers used
   regcnt is the total number of reg registers used

   postpre is the first pre register to read in the post phase (0=p1).

   pre/exe registers are 32-bit registers visible from the µcode.
   reg registers are not real registers -- they are internal to the decoding
   unit and are used for telling 'regwrite' fragments in the post stage which
   32-bit registers to use.  Reg registers only need 5 bits each.

   Every time the canned µcode from pre/post fragments make an <pre> or <exe>
   reference, the decoder increments an internal register so the next reference
   gets a new register number.

   The pre state start pre/exe with the first pre and exe registers.
   The post state starts out with the first exe register but it can't just start
   with the first pre register.

   If there is no post phase then the postpre value doesn't matter (all values
   are harmless).

   precnt/execnt/regcnt are only used for informational/validation purposes --
   postpre is the only value that is used in the simulator.
 */
struct alloc {
	unsigned	precnt;
	unsigned	execnt;
	unsigned	regcnt;
	unsigned	postpre;
};


struct alloc alloc[512] = {};


/* How the actual register allocation and the fragment breakdown works.

FIXME: use a table in vax-tables.h, generated by instr-extr.pl?

 */
struct {
	const char	*pair; /* two-letter access/data type */
	unsigned	 pre;
	unsigned	 exe;
	unsigned	 reg;
	bool		 write;
} opclass[] = {
	/*     pre  exe  reg  write? */
/* read */
	{"rb", 1,   0,   0,   false},
	{"rw", 1,   0,   0,   false},
	{"rl", 1,   0,   0,   false},
	{"rf", 1,   0,   0,   false},

	{"rq", 2,   0,   0,   false},
	{"rd", 2,   0,   0,   false},
	{"rg", 2,   0,   0,   false},

/* modify*/
	{"mb", 2,   1,   1,   true},
	{"mw", 2,   1,   1,   true},
	{"ml", 2,   1,   1,   true},
	{"mf", 2,   1,   1,   true},

	{"mq", 3,   2,   1,   true},
	{"md", 3,   2,   1,   true},
	{"mg", 3,   2,   1,   true},

/* write */
	{"wb", 1,   1,   1,   true},
	{"ww", 1,   1,   1,   true},
	{"wl", 1,   1,   1,   true},
	{"wf", 1,   1,   1,   true},

	{"wq", 1,   2,   1,   true},
	{"wd", 1,   2,   1,   true},
	{"wg", 1,   2,   1,   true},

/* address */
	{"ab", 1,   0,   0,   false},
	{"aw", 1,   0,   0,   false},
	{"al", 1,   0,   0,   false},
	{"aq", 1,   0,   0,   false},

/* vector */
	{"vb", 0,   0,   0,   false}, /* FIXME */
};


int class(const char *pair)
{
	for (unsigned i=0; i<ARRAY_SIZE(opclass); i++)
		if (strcmp(pair, opclass[i].pair) == 0)
			return i;

	fprintf(stderr, "unknown access/data pair (%s)\n", pair);
	assert(0);
}


int		 paircnt[100];
const char	*pairname[100];
unsigned	 pairc;


/* analyze a single instruction */
void analyze_op(unsigned op)
{
	/* alloc[op] is supposed to be zero-initialized on entry */

	/* loop through the operand list */
	for (unsigned i=0; i < strlen(ops[op]); i+=3) {
		char	pair[3];

		pair[0] = ops[op][i];
		pair[1] = ops[op][i+1];
		pair[2] = '\0';

		/* count operand pair */
		for (unsigned j=0; j < pairc; j++) {
			if (strcmp(pair, pairname[j]) == 0) {
				paircnt[j]++;
				goto xxxx;
			}
		}

		pairname[pairc] = strdup(pair);
		paircnt[pairc]  = 1;
		pairc++;
xxxx:

		/* bb = branch, byte displacement
		   bw = branch, word displacement

		   branch instructions don't have normal operands with
		   operand descriptors, so skip them.
		 */
		if ((strcmp(pair, "bb") == 0) || (strcmp(pair, "bw") == 0))
			break;

		int c = class(pair);

		/* if this is the first write/modify operand, remember what
		   pre register it uses for the address.
		 */
		if (opclass[c].write && !alloc[op].postpre)
			alloc[op].postpre = alloc[op].precnt;

		alloc[op].precnt += opclass[c].pre;
		alloc[op].execnt += opclass[c].exe;
		alloc[op].regcnt += opclass[c].reg;
	}
}


void analyze()
{
	/* alloc[] is supposed to be zero-initialized on entry */

	/* look closely ateach instruction */
	for (unsigned op=0; op<ARRAY_SIZE(ops); op++) {
		if (strcmp(ops[op], "") == 0)
			continue;

		analyze_op(op);
	}
}


void output_txt()
{
	printf("\n");
	printf("------------------------------\n");
	for (unsigned op=0; op<ARRAY_SIZE(alloc); op++) {
		if (op == 0)
			printf("*** single-byte opcodes\n\n");
		if (op == 256)
			printf("*** FD prefix\n\n");
		if ((op & 0x0F) == 0) {
			printf("           pre exe reg postpre\n");
		}
		printf("%02X %-6s  %d   %d   %d   %d\n",
			op & 0xFF, mne[op],
			alloc[op].precnt, alloc[op].execnt, alloc[op].regcnt,
			alloc[op].postpre);
		if ((op & 0x0F) == 0x0F) {
			printf("\n");
		}
	}

	printf("\n");
	int	maxpre=-1;
	int	maxexe=-1;
	int	maxreg=-1;
	int	maxsum=-1;

	for (unsigned op=0; op<ARRAY_SIZE(alloc); op++) {
		if ((int) alloc[op].precnt > maxpre)
			maxpre = alloc[op].precnt;
		if ((int) alloc[op].execnt > maxexe)
			maxexe = alloc[op].execnt;
		if ((int) alloc[op].regcnt > maxreg)
			maxreg = alloc[op].regcnt;
		int sum = alloc[op].precnt + alloc[op].execnt;
		if (sum > maxsum)
			maxsum = sum;
	}

	/* Assume that pre and exe registers are non-overlapping.
	   We could conceivably get by with slightly fewer internal registers
	   with some overlap and reuse.

	   Even with 16 GPRs, 1 PSL, 10 fragment registers, and 2 tmp regs,
	   we are still only at 29 regs, so still below 32.
	 */
	printf("max pre: %d\n", maxpre);
	printf("max exe: %d\n", maxexe);
	printf("max reg: %d\n", maxreg);
	printf("max sum: %d (total number of registers needed)\n", maxsum);
	printf("\n");
	printf("------------------------------\n");
	printf("\n");

	/* sort the operand pair names (quick'n'dirty bubble sort) */
	while (1) {
		bool	swapped = false;

		for (unsigned i=0; i+1<pairc; i++)
			if (strcmp(pairname[i], pairname[i+1]) > 0) {
				const char	*tmpname;
				int		 tmpcnt;

				tmpname = pairname[i];
				pairname[i] = pairname[i+1];
				pairname[i+1] = tmpname;

				tmpcnt = paircnt[i];
				paircnt[i] = paircnt[i+1];
				paircnt[i+1] = tmpcnt;

				swapped = true;
			}

		if (!swapped)
			break;
	}

	/* print them out */
	printf("Access/data type combinations:\n");
	printf("\n");
	char lastaccess = 'a';
	for (unsigned i=0; i < pairc; i++) {
		if (pairname[i][0] != lastaccess) {
			lastaccess = pairname[i][0];
			printf("\n");
		}
		printf("%s %3d\n", pairname[i], paircnt[i]);
	}
	printf("\n");
}


#if 0
void output_c()
{
	/* FIXME -- do I actually even need this for the decoder?  I think not */

	printf("unsigned op_postpre[%d] = {\n", (int) ARRAY_SIZE(alloc));
	for (unsigned op=0; op<ARRAY_SIZE(alloc); op++) {
		if (op == 0) {
			printf("/* single-byte opcodes */\n\n");
		}
		if (op == 256) {
			printf("/* FD prefix */\n\n");
		}
		if (strcmp(mne[op], "") == 0)
			printf("/* %02X %-6s */ %d,\n", op & 0xFF, "---", 0);
		else
			printf("/* %02X %-6s */ %d,\n", op & 0xFF, mne[op], alloc[op].postpre);

		if (((op & 0x0F) == 0x0F) && (op+1 < ARRAY_SIZE(alloc)))
			printf("\n");
	}
	printf("};\n");
}
#endif


/* wrote this first as a warm-up exercise */
void multi_output()
{
	printf("Instructions with >1 output:\n");
	for (unsigned op=0; op<ARRAY_SIZE(ops); op++) {
		if (strcmp(ops[op], "") == 0)
			continue;

		assert((strlen(ops[op]) % 3) == 0);

		unsigned	wcnt = 0;
		unsigned	firstw = 0;
		for (unsigned i=0; i < strlen(ops[op]); i+=3)
			if ((ops[op][i] == 'w') || (ops[op][i] == 'm')) {
				wcnt++;
				if (!firstw)
					firstw = i;
			}

		if (wcnt > 1) {
			printf("%-6s  ", mne[op]);
			for (unsigned i=0; i < 18; i+=3) {
				if (i >= strlen(ops[op])) {
					printf("   ");
					continue;
				}
				if (i == firstw)
					printf("| ");
				printf("%c%c ", ops[op][i], ops[op][i+1]);
			}
			printf("  %d writes\n", wcnt);
		}
	}
}


int main()
{
	multi_output();

	analyze();

	output_txt();
#if 0
	output_c();
#endif

	return EXIT_SUCCESS;
}

