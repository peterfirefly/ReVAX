.TOC	"MACRO.MIC -- Macro Definitions"
.TOC	"Revision 3.1"

;	Shawn Persels, Bob Supnik

.nobin
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1985, 1986, 1987 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************

.TOC	"	Revision History"

;	8-Jan-87	[RMS]	Updated copyright notice, pass 2 code freeze
; 03	5-Jul-86	[RMS]	Editorial changes, pass 1 code freeze
;	15-May-86	[RMS]	Added macros for interlocked m bit update (ECO 5DEC27RMS.1)
;	28-Mar-86	[RMS]	Generalized unary BASIC macros
;	31-Jan-86	[RMS]	Added DEC.NEXT validity checks
;	6-Jan-86	[RMS]	Changed SWAP.RN to LOAD.OLD.RN (ECO 6JAN08DWA.1)
;	29-Dec-85	[RMS]	Revised LEN(DL) macro for new validity check
;	19-Sep-85	[RMS]	Removed ZEXT, ZEXTB macros (ECO 5SEP19FF.1)
;	12-Sep-85	[RMS]	Added CLEAR.WRITE.BUFFER function (ECO 5SEP10PIR.1)
;	26-Jun-85	[RMS]	Fixed bug in single operand shift macros
;	21-Jun-85	[RMS]	Eliminated spurious FPA broadcasts
; 02	18-Mar-85	[RMS]	Revised for second pass model
; 01	15-Feb-85	[SDP]	Revised destination select macros for new register file addressing scheme
; 00	4-May-84	[RMS]	First edit for CVAX

.TOC	"	BASIC Format Macros"

;	Two operand BASIC macros always have the A as the first operand,
;	followed by the B field.  The choice of destination mode is made
;	automatically by the macros, using the following pseudo-field.

.SET/BASIC.DST=<.SELECT[	<.EQL[<W/>,<W/WBUS>]>,			<DST/DST.ZILCH>,
				<.EQL[<W/>,<W/WSN>]>,			<DST/DST.WSN>,
				<.EQL[<W/>,<A/>]>,			<DST/DST.A>,
				<.EQL[<W/>,<PB/>]>,			<DST/DST.B>,
				<1>,					<DST/100>	]>

[]<--[]+[]			"BASIC/FORMAT,BASIC.FNC/A.PLUS.B,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"
[]<--[]+[]+1			"BASIC/FORMAT,BASIC.FNC/A.PLUS.B.PLUS.1,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,
				 DST/<BASIC.DST>"
[]<--[]+[]+PSL.C		"BASIC/FORMAT,BASIC.FNC/A.PLUS.B.PLUS.PSL.C,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,
				 DST/<BASIC.DST>"
[]<--[]-[]			"BASIC/FORMAT,BASIC.FNC/A.MINUS.B,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"
[]<--[]-[]-PSL.C		"BASIC/FORMAT,BASIC.FNC/A.MINUS.B.MINUS.PSL.C,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,
				 DST/<BASIC.DST>"
[]<--[].AND.[]			"BASIC/FORMAT,BASIC.FNC/A.AND.B,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"
[]<--[].ANDNOT.[]		"BASIC/FORMAT,BASIC.FNC/A.AND.NOT.B,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"
[]<--[].OR.[]			"BASIC/FORMAT,BASIC.FNC/A.OR.B,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"
[]<--[].XOR.[]			"BASIC/FORMAT,BASIC.FNC/A.XOR.B,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"
[]<--[].SMULS.[]		"BASIC/FORMAT,BASIC.FNC/SMUL.STEP,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"
[]<--[].UDIVS.[]		"BASIC/FORMAT,BASIC.FNC/UDIV.STEP,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"
[]<--(-[]+[])			"BASIC/FORMAT,BASIC.FNC/B.MINUS.A,W/@1,A/@2,PB/@3,B/<.AND[<PB/>,0F]>,DST/<BASIC.DST>"

NOP				"BASIC/FORMAT,BASIC.FNC/PASS.A,A/0,B/0,DST/DST.ZILCH"

;	Basic format macros, continued.

;	Unary operation on B port select.
;	Set destination mode based on destination, source.

.SET/UNARY.B.DST=<.SELECT[	<.EQL[<W/>,<W/WBUS>]>,			<DST/DST.ZILCH>,
				<.EQL[<W/>,<W/WSN>]>,			<DST/DST.WSN>,
				<.EQL[<W/>,<PB/>]>,			<DST/DST.B>,
				<.LEQ[<W/>,3A]>,			<DST/DST.A>,
				<1>,					<DST/100>	]>

;	Set A port select if required to select destination.

.SET/UNARY.B.ASEL=<.SELECT[	<.EQL[<W/>,<W/WBUS>]>,			<A/0>,
				<.EQL[<W/>,<W/WSN>]>,			<A/WSN>,
				<.EQL[<W/>,<PB/>]>,			<A/0>,
				<.LEQ[<W/>,3A]>,			<W/>,
				<1>,					<A/100>		]>

[]<--B.[]			"BASIC/FORMAT,BASIC.FNC/PASS.B,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/<UNARY.B.ASEL>,
				 DST/<UNARY.B.DST>"
[]<--NEG.[]			"BASIC/FORMAT,BASIC.FNC/NEG.B,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/<UNARY.B.ASEL>,
				 DST/<UNARY.B.DST>"
[]<--NOT.[]			"BASIC/FORMAT,BASIC.FNC/NOT.B,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/<UNARY.B.ASEL>,
				 DST/<UNARY.B.DST>"

;	Unary operation on A port select.
;	Set destination mode based on destination, source.

.SET/UNARY.A.DST=<.SELECT[	<.EQL[<W/>,<W/WBUS>]>,			<DST/DST.ZILCH>,
				<.EQL[<W/>,<W/WSN>]>,			<DST/DST.WSN>,
				<.EQL[<W/>,<A/>]>,			<DST/DST.A>,
				<.OR[	<.AND[	<.GEQ[<W/>,20]>,<.LEQ[<W/>,29]>]>,
					<.AND[	<.GEQ[<W/>,3C]>,<.LEQ[<W/>,3E]>]>]>,
									<DST/DST.B>,
				<1>,					<DST/100>	]>

;	Set B port select if required to select destination.

.SET/UNARY.A.BSEL=<.SELECT[	<.EQL[<W/>,<W/WBUS>]>,			<B/0>,
				<.EQL[<W/>,<W/WSN>]>,			<PB/WSN>,
				<.EQL[<W/>,<A/>]>,			<B/0>,
				<.OR[	<.AND[	<.GEQ[<W/>,20]>,<.LEQ[<W/>,29]>]>,
					<.AND[	<.GEQ[<W/>,3C]>,<.LEQ[<W/>,3E]>]>]>,
									<W/>,
				<1>,					<B/100>		]>

[]<--[]				"BASIC/FORMAT,BASIC.FNC/PASS.A,W/@1,A/@2,PB/<UNARY.A.BSEL>,B/<.AND[<PB/>,0F]>,
				 DST/<UNARY.A.DST>"
[]<--[]+1			"BASIC/FORMAT,BASIC.FNC/A.PLUS.1,W/@1,A/@2,PB/<UNARY.A.BSEL>,B/<.AND[<PB/>,0F]>,
				 DST/<UNARY.A.DST>"
[]<--[]-1			"BASIC/FORMAT,BASIC.FNC/A.MINUS.1,W/@1,A/@2,PB/<UNARY.A.BSEL>,B/<.AND[<PB/>,0F]>,
				 DST/<UNARY.A.DST>"

.TOC	"	CONSTANT Format Macros"

;	CONSTANT macros always have a constant operand, denoted by K,
;	a destination operand, and possibly a source operand.  The
;	choice of destination mode is made automatically by the macros,
;	using the following pseudo-field.

.SET/CONSTANT.DST=<.SELECT[	<.EQL[<W/>,<W/WBUS>]>,			<CONST.DST/DST.ZILCH>,
				<.EQL[<W/>,<A/>]>,			<CONST.DST/DST.A>,
				<1>,					<CONST.DST/100>		]>

.SET/A.EQ.W=<.SELECT[		<.EQL[<W/>,<W/WBUS>]>,			<A/0>,
				<.LEQ[<W/>,3A]>,			<W/>,
				<1>,					<A/100>			]>

[]<--[]+K[]			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/A.PLUS.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[]-K[]			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/A.MINUS.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--K[]-[]			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/CONST.MINUS.A,CONST.BYTE/@2,
				 W/@1,A/@3,CONST.DST/<CONSTANT.DST>"
[]<--[].AND.K[]			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/A.AND.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[].OR.K[]			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/A.OR.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--K[]			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/CONST,CONST.BYTE/@2,
				 W/@1,A/<A.EQ.W>,CONST.DST/<CONSTANT.DST>"
[]<--[].ANDNOT.K[]		"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/A.AND.NOT.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[].XOR.K[]			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/A.XOR.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"

[]<--[]+K[]0			"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/A.PLUS.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[]-K[]0			"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/A.MINUS.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--K[]0-[]			"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/CONST.MINUS.A,CONST.BYTE/@2,
				 W/@1,A/@3,CONST.DST/<CONSTANT.DST>"
[]<--[].AND.K[]0		"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/A.AND.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[].OR.K[]0			"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/A.OR.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--K[]0			"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/CONST,CONST.BYTE/@2,
				 W/@1,A/<A.EQ.W>,CONST.DST/<CONSTANT.DST>"
[]<--[].ANDNOT.K[]0		"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/A.AND.NOT.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[].XOR.K[]0		"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/A.XOR.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"

;	Constant format macros, continued.

[]<--[]+K[]00			"CONST/FORMAT,CONST.POS/BYTE2,CONST.FNC/A.PLUS.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[]-K[]00			"CONST/FORMAT,CONST.POS/BYTE2,CONST.FNC/A.MINUS.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--K[]00-[]			"CONST/FORMAT,CONST.POS/BYTE2,CONST.FNC/CONST.MINUS.A,CONST.BYTE/@2,
				 W/@1,A/@3,CONST.DST/<CONSTANT.DST>"
[]<--[].AND.K[]00		"CONST/FORMAT,CONST.POS/BYTE2,CONST.FNC/A.AND.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[].OR.K[]00		"CONST/FORMAT,CONST.POS/BYTE2,CONST.FNC/A.OR.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--K[]00			"CONST/FORMAT,CONST.POS/BYTE2,CONST.FNC/CONST,CONST.BYTE/@2,
				 W/@1,A/<A.EQ.W>,CONST.DST/<CONSTANT.DST>"
[]<--[].ANDNOT.K[]00		"CONST/FORMAT,CONST.POS/BYTE2,CONST.FNC/A.AND.NOT.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[].XOR.K[]00		"CONST/FORMAT,CONST.POS/BYTE2,CONST.FNC/A.XOR.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"

[]<--[]+K[]000			"CONST/FORMAT,CONST.POS/BYTE3,CONST.FNC/A.PLUS.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[]-K[]000			"CONST/FORMAT,CONST.POS/BYTE3,CONST.FNC/A.MINUS.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--K[]000-[]			"CONST/FORMAT,CONST.POS/BYTE3,CONST.FNC/CONST.MINUS.A,CONST.BYTE/@2,
				 W/@1,A/@3,CONST.DST/<CONSTANT.DST>"
[]<--[].AND.K[]000		"CONST/FORMAT,CONST.POS/BYTE3,CONST.FNC/A.AND.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[].OR.K[]000		"CONST/FORMAT,CONST.POS/BYTE3,CONST.FNC/A.OR.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--K[]000			"CONST/FORMAT,CONST.POS/BYTE3,CONST.FNC/CONST,CONST.BYTE/@2,
				 W/@1,A/<A.EQ.W>,CONST.DST/<CONSTANT.DST>"
[]<--[].ANDNOT.K[]000		"CONST/FORMAT,CONST.POS/BYTE3,CONST.FNC/A.AND.NOT.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"
[]<--[].XOR.K[]000		"CONST/FORMAT,CONST.POS/BYTE3,CONST.FNC/A.XOR.CONST,CONST.BYTE/@3,
				 W/@1,A/@2,CONST.DST/<CONSTANT.DST>"

SET.PSL.V			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/A.OR.CONST,CONST.BYTE/2,
				 A/PSL,CONST.DST/DST.A"
CONSOLE.HALT[]			"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/CONST,CONST.BYTE/@1,
				 A/SAVEPSL,CONST.DST/DST.A,MISC/DISABLE.IB.PREFETCH,GOTO[CONSOLE.HALT]"
MACHINE.CHECK[]			"CONST/FORMAT,CONST.POS/BYTE0,CONST.FNC/CONST,CONST.BYTE/@1,
				 A/TMMGT,CONST.DST/DST.A,MISC/DISABLE.IB.PREFETCH,GOTO[MACHINE.CHECK]"
CONSOLE.HALT.PARAM[]		"CONST/FORMAT,CONST.POS/BYTE1,CONST.FNC/CONST,CONST.BYTE/@1,
				 A/SAVEPSL,CONST.DST/DST.A,MISC/DISABLE.IB.PREFETCH"

.TOC	"	SHIFT Format Macros"

;	SHIFT macros can take a variety of destinations, depending on whether the
;	shift is left or right, and on whether the A or B bus operand is suppressed.

.SET/SHIFT.DST=<.SELECT[	<.EQL[<W/>,<W/WBUS>]>,			<DST/DST.ZILCH>,
				<.EQL[<W/>,<W/WSN>]>,			<DST/DST.WSN>,
				<.AND[	<.EQL[<W/>,<PB/>]>,
					<.EQL[<SHIFT.DIR/>,<SHIFT.DIR/RIGHT>]>]>,
									<DST/DST.B>,
				<.AND[	<.EQL[<W/>,<A/>]>,
					<.EQL[<SHIFT.DIR/>,<SHIFT.DIR/LEFT>]>]>,
									<DST/DST.A>,
				<1>,					<DST/100>	]>

[]<--[].ROTL.[]			"SHIFT/FORMAT,SHIFT.VAL/@3,SHIFT.DIR/LEFT,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--[].ROTL.(SC)		"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/LEFT,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--[].ROTR.[]			"SHIFT/FORMAT,SHIFT.VAL/@3,SHIFT.DIR/RIGHT,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--[].ROTR.(SC)		"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/RIGHT,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--[]!![].SHFL.[]		"SHIFT/FORMAT,SHIFT.VAL/@4,SHIFT.DIR/LEFT,W/@1,PB/@3,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--[]!![].SHFL.(SC)		"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/LEFT,W/@1,PB/@3,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--[]!![].SHFR.[]		"SHIFT/FORMAT,SHIFT.VAL/@4,SHIFT.DIR/RIGHT,W/@1,PB/@3,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--[]!![].SHFR.(SC)		"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/RIGHT,W/@1,PB/@3,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--[]!![].SHFR.(32-SC)	"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/LEFT,W/@1,PB/@3,B/<.AND[<PB/>,0F]>,A/@2,
				 DST/<SHIFT.DST>"
[]<--SEXT.[].SHFR.[]		"SHIFT/FORMAT,SHIFT.VAL/@3,SHIFT.DIR/RIGHT,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/SEXTN,
				 DST/<SHIFT.DST>"
[]<--SEXT.[].SHFR.(SC)		"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/RIGHT,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/SEXTN,
				 DST/<SHIFT.DST>"
[]<--SEXT.[].SHFR.(32-SC)	"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/LEFT,W/@1,PB/@2,B/<.AND[<PB/>,0F]>,A/SEXTN,
				 DST/<SHIFT.DST>"

[]<--[].SHFL.[]			"SHIFT/FORMAT,SHIFT.VAL/@3,SHIFT.DIR/LEFT,PB/@1,A/@2,B/<.AND[<PB/>,0F]>,DST/DST.B"
[]<--[].SHFL.(SC)		"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/LEFT,PB/@1,A/@2,B/<.AND[<PB/>,0F]>,DST/DST.B"
[]<--ZEXT.[].SHFR.[]		"SHIFT/FORMAT,SHIFT.VAL/@3,SHIFT.DIR/RIGHT,A/@1,PB/@2,B/<.AND[<PB/>,0F]>,DST/DST.A"
[]<--ZEXT.[].SHFR.(SC)		"SHIFT/FORMAT,SHIFT.VAL/0,SHIFT.DIR/RIGHT,A/@1,PB/@2,B/<.AND[<PB/>,0F]>,DST/DST.A"

.TOC	"	MEM REQ Format Macros"

;	MEMREQ read macros always have the A_bus as the first operand.
;	The choice of destination mode is made automatically by the
;	macros, using the following pseudo-field.

.SET/MEMORY.DST=<.SELECT[	<.EQL[<W/>,<W/WBUS>]>,			<DST/DST.ZILCH>,
				<.EQL[<W/>,<A/>]>,			<DST/DST.A>,
				<1>,					<DST/100>	]>

[]<--MEM(VA)			"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VA,MEMREQ.ACC/RCHK.CURR,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VA).CHECK(AT)		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VA,MEMREQ.ACC/AT.CURR,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VA).LOCK		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VA.LOCK,MEMREQ.ACC/WCHK.CURR,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VA).IPR		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VA.IPR,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VA).PHYS		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VA,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VA).WCHECK		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VA,MEMREQ.ACC/WCHK.CURR,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VAP)			"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VAP,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VAP).LOCK		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VAP.LOCK,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VAP).INTVEC		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VAP.INTVEC,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VAP).PPTE		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VAP.PTE,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VAP).PHYS		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VAP,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VAP).PHYS.LOCK		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VAP.LOCK,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
[]<--MEM(VAP).SPTE		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VAP.PTE,MEMREQ.ACC/NONE,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"

MEM(VA)<--[]			"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VA,MEMREQ.ACC/WCHK.CURR,A/@1,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
MEM(VA).IPR<--[]		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VA.IPR,MEMREQ.ACC/NONE,A/@1,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
MEM(VA).PHYS<--[]		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VA,MEMREQ.ACC/NONE,A/@1,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
MEM(VA).UNLOCK<--[]		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VA.LOCK,MEMREQ.ACC/WCHK.CURR,A/@1,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
MEM(VAP)<--[]			"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VAP,MEMREQ.ACC/NONE,A/@1,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
MEM(VAP).UNLOCK<--[]		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.VIRT.VAP.LOCK,MEMREQ.ACC/NONE,A/@1,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
MEM(VAP).PHYS<--[]		"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VAP,MEMREQ.ACC/NONE,A/@1,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
MEM(VAP).PHYS.UNLOCK<--[]	"MEMREQ/FORMAT,MEMREQ.FNC/MEM.PHYS.VAP.LOCK,MEMREQ.ACC/NONE,A/@1,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"

;	MEM REQ format macros, continued.

PROBE.READ.CURMODE		"MEMREQ/FORMAT,MEMREQ.FNC/PROBE.VIRT.VA,MEMREQ.ACC/RCHK.CURR,A/0,
				 MEMREQ.RW/READ,DST/DST.ZILCH"
PROBE.WRITE.CURMODE		"MEMREQ/FORMAT,MEMREQ.FNC/PROBE.VIRT.VA,MEMREQ.ACC/WCHK.CURR,A/0,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
PROBE.READ.MODE			"MEMREQ/FORMAT,MEMREQ.FNC/PROBE.VIRT.VA,MEMREQ.ACC/RCHK.MODE,A/0,
				 MEMREQ.RW/READ,DST/DST.ZILCH"
PROBE.WRITE.MODE		"MEMREQ/FORMAT,MEMREQ.FNC/PROBE.VIRT.VA,MEMREQ.ACC/WCHK.MODE,A/0,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
PROBE.NOACCHK			"MEMREQ/FORMAT,MEMREQ.FNC/PROBE.VIRT.VA,MEMREQ.ACC/NONE,A/0,
				 MEMREQ.RW/READ,DST/DST.ZILCH"
PROBE.NOACCHK.VAP		"MEMREQ/FORMAT,MEMREQ.FNC/PROBE.VIRT.VAP,MEMREQ.ACC/NONE,A/0,
				 MEMREQ.RW/READ,DST/DST.ZILCH"

[]<--FPA.DATA			"MEMREQ/FORMAT,MEMREQ.FNC/FPA.DATA,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"

[]<--MXPR[]			"MEMREQ/FORMAT,MEMREQ.FNC/MXPR,MEMREQ.PR/@2,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
MXPR[]<--[]			"MEMREQ/FORMAT,MEMREQ.FNC/MXPR,MEMREQ.PR/@1,A/@2,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"

[]<--MXPS0[]			"MEMREQ/FORMAT,MEMREQ.FNC/MXPS0,MEMREQ.REG.RD.0/@2,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
MXPS0[]<--[]			"MEMREQ/FORMAT,MEMREQ.FNC/MXPS0,MEMREQ.REG.WR.0/@1,A/@2,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"
[]<--MXPS1[]			"MEMREQ/FORMAT,MEMREQ.FNC/MXPS1,MEMREQ.REG.RD.1/@2,W/@1,A/<A.EQ.W>,
				 MEMREQ.RW/READ,DST/<MEMORY.DST>"
MXPS1[]<--[]			"MEMREQ/FORMAT,MEMREQ.FNC/MXPS1,MEMREQ.REG.WR.1/@1,A/@2,
				 MEMREQ.RW/WRITE,DST/DST.ZILCH"

.TOC	"	SPECIAL Format Macros"

CLEAR.VAX.TRAP.REQUEST		"SPECIAL/FORMAT,SPECIAL.MISC1/CLEAR.VAX.TRAP.REQUEST"
SET.VAX.TRAP.REQUEST		"SPECIAL/FORMAT,SPECIAL.MISC1/SET.VAX.TRAP.REQUEST"
ZAP.TB				"SPECIAL/FORMAT,SPECIAL.MISC1/ZAP.TB"
ZAP.TB(HIT).IF.HIT		"SPECIAL/FORMAT,SPECIAL.MISC1/ZAP.TB(HIT).IF.HIT"
SET.REPROBE			"SPECIAL/FORMAT,SPECIAL.MISC1/SET.REPROBE"
SET.MMGT.TD			"SPECIAL/FORMAT,SPECIAL.MISC1/SET.MMGT.TD"
HALT				"SPECIAL/FORMAT,SPECIAL.MISC1/HALT"

PC<--BPC			"SPECIAL/FORMAT,SPECIAL.MISC2/LOAD.PC.FROM.BPC"

STATE5-4<--0			"SPECIAL/FORMAT,SPECIAL.MISC3/CLEAR.STATE.5-4"
STATE3<--1			"SPECIAL/FORMAT,SPECIAL.MISC3/SET.STATE.3"
STATE4<--1			"SPECIAL/FORMAT,SPECIAL.MISC3/SET.STATE.4"
STATE5<--1			"SPECIAL/FORMAT,SPECIAL.MISC3/SET.STATE.5"

.TOC	"	LENGTH Field Macros"

;	LENGTH macros are treated as follows:  LONG is ignored,
;	since the length field defaults to long in microinstructions
;	which have a length field, and is implied to be long in
;	microinstructions which do not have one.  LEN(DL) sets the
;	length bit where appropriate.

LEN(DL)				"L/LEN(DL)"
LONG				"A/<A/>"		; macro must do something

.TOC	"	CC Field Macros"

SET.ALUCC			"CC/LOAD.ALU.CC"
SET.PSLCC			"CC/LOAD.PSL.CC"
SET.ALUCC&PSLCC			"CC/LOAD.ALU.CC&PSL.CC"

.TOC	"	MISC Field Macros"

VA&				"MISC/WRITE.VA"
VAP&				"MISC/WRITE.VAP"
SC&				"MISC/WRITE.SC"
CLEAR.WRITE.BUFFER		"MISC/CLEAR.WRITE.BUFFER"
RESTART.PREFETCH		"MISC/RESTART.PREFETCH"
ENABLE.IB.PREFETCH		"MISC/ENABLE.IB.PREFETCH"
DISABLE.IB.PREFETCH		"MISC/DISABLE.IB.PREFETCH"
RN<--0				"MISC/CLEAR.RN"
RN<--RN-1			"MISC/RN.MINUS.1"
RN<--RN+1			"MISC/RN.PLUS.1"
RN<--RN+DL.Q			"MISC/RN.PLUS.DL.Q"
RN<--RN.OLD			"MISC/LOAD.OLD.RN"
DL<--BYTE			"MISC/DL.BYTE"
DL<--WORD			"MISC/DL.WORD"
DL<--LONG			"MISC/DL.LONG"
DL<--QUAD			"MISC/DL.QUAD"
STATE3-0<--0			"MISC/CLEAR.STATE.3-0"
STATE0<--1			"MISC/SET.STATE.0"
STATE1<--1			"MISC/SET.STATE.1"
STATE2<--1			"MISC/SET.STATE.2"
SET.REEXECUTE			"MISC/SET.REEXECUTE"
CLEAR.MMGT.TD			"MISC/CLEAR.MMGT.TD"
LOAD.V&PC			"MISC/LOAD.V&PC"
IF.BCOND.LOAD.V&PC		"MISC/IF.BCOND.LOAD.V&PC"
IF.BCOND.LOAD.V&PC.TRAP		"MISC/IF.BCOND.LOAD.V&PC.TRAP"
OLD.Z.AND.NEW.Z			"MISC/OLD.Z"
USE.DL				"MISC/SHIFT.DL"
RLOG				"MISC/RLOG"
MAP.JIZJ			"MISC/MAP.JIZJ"
MAP.IIII			"MISC/MAP.IIII"
MAP.IIIJ			"MISC/MAP.IIIJ"

.TOC	"	BRANCH Format Macros"

CASE2[].AT.[]			"BRANCH/FORMAT,BR.BCS/@1,BR64T.OFF/@2"
CASE4[].AT.[]			"BRANCH/FORMAT,BR.BCS/@1,BR64T.OFF/@2"
CASE8[].AT.[]			"BRANCH/FORMAT,BR.BCS/@1,BR64T.OFF/@2"

DEC.NEXT			"BRANCH/FORMAT,BR.BCS/DEC.NEXT,BR64T.OFF/0"
IF(DL.BWL)_DEC.NEXT		"BRANCH/FORMAT,BR.BCS/DL.BWL_DEC.NEXT"
IF(DL.BWL)_DEC.NEXT.ELSE.[]	"BRANCH/FORMAT,BR.BCS/DL.BWL_DEC.NEXT,BR64T.OFF/@1"

SPEC.NEXT			"BRANCH/FORMAT,BR.BCS/SPEC.NEXT,BR64T.OFF/0"
IF(DL.BWL)_SPEC.NEXT		"BRANCH/FORMAT,BR.BCS/DL.BWL_SPEC.NEXT"
IF(DL.BWL)_SPEC.NEXT.ELSE.[]	"BRANCH/FORMAT,BR.BCS/DL.BWL_SPEC.NEXT,BR64T.OFF/@1"

IF(AT.AV)_SPEC.NEXT		"BRANCH/FORMAT,BR.BCS/AT.AV_SPEC.NEXT"
IF(AT.AV)_SPEC.NEXT.ELSE.[]	"BRANCH/FORMAT,BR.BCS/AT.AV_SPEC.NEXT,BR64T.OFF/@1"

IF(DL.BWL.AT.RVM)_SPEC.NEXT	"BRANCH/FORMAT,BR.BCS/DL.BWL.AT.RVM_SPEC.NEXT"
IF(AT.RVM)_SPEC.NEXT.ELSE.[]	"BRANCH/FORMAT,BR.BCS/AT.RVM_SPEC.NEXT,BR64T.OFF/@1"
IF(DL.BWL.AT.R)_SPEC.NEXT	"BRANCH/FORMAT,BR.BCS/DL.BWL.AT.R_SPEC.NEXT"
IF(AT.R)_SPEC.NEXT.ELSE.[]	"BRANCH/FORMAT,BR.BCS/AT.R_SPEC.NEXT,BR64T.OFF/@1"

RETURN				"BRANCH/FORMAT,BR.BCS/RET,BR64T.OFF/0"

.TOC	"	JUMP Format Macros"

CALL[]				"JUMP/FORMAT,JMP.SUB/CALL,JMP.ADD/<BR64T.OFF/@1>"
GOTO[]				"JUMP/FORMAT,JMP.SUB/NOCALL,JMP.ADD/<BR64T.OFF/@1>"
.bin
