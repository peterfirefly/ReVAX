/* Copyright 2018  Peter Lund <firefly@vax64.dk>

   Licensed under GPL v2.

   ---

   operand handling support code

   called by autogenerated code for asm/dis/sim/val.

 */

#ifndef OP_SUPPORT__H
#define OP_SUPPORT__H

#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "big-int.h"

#include "parse.h"


/***/


/* worst-case is octo/h immediate operands: 1 opspec + 16 data bytes */
#define MAX_OPLEN	17

enum ifp	{ IFP_INT, IFP_F, IFP_D, IFP_G, IFP_H };


struct fields {
	int		Rn, Rx;
	int32_t		addr;
	int32_t		disp;

	struct big_int	imm;
	int8_t		lit6;
};


/* operand class

   IMM/REG/ADDR

   anything >= 0 is interpreted as ADDR class (where the actual value is the
   microcode address).
 */
#define CLASS_IMM	-2
#define CLASS_REG	-1


/* string buffer types */
typedef char disstr[100];
typedef char dis_part_str[50];


/***/

/* FIXME there's also a set of register names in the generated file src/vax-ucode.h

   should one of them be eliminated?
 */

struct {
	int		no;
	const char	name[5];
} regs[] = {
	/* preferred names first */
	{12, "ap"},
	{13, "fp"},
	{14, "sp"},
	{15, "pc"},

	{ 0, "r0"},
	{ 1, "r1"},
	{ 2, "r2"},
	{ 3, "r3"},
	{ 4, "r4"},
	{ 5, "r5"},
	{ 6, "r6"},
	{ 7, "r7"},
	{ 8, "r8"},
	{ 9, "r9"},
	{10, "r10"},
	{11, "r11"},
	{12, "r12"},
	{13, "r13"},
	{14, "r14"},
	{15, "r15"},
};


/***/


/* packing/unpacking -- used by op-asm.h, op-dis.h, op-sim.h, op-val.h.

   using '|' instead of '+' to combine the parts work better with the idiom
   recognizers in gcc/clang.

   casting the uint8_t bytes to unsigned/uint32_t before the shifts avoids
   the undefined behaviour with '<< 24' and ints (int promotion!) and also
   makes the idiom recognizers work better.
 */
#define BYTE(x, n)	(((x) >> (n*8)) & 0xFF)


/* double cast trick works in both gcc and clang.
   B   is recognized as an idiom by at least gcc 4.7+ and clang 3.9+
   W/L are recognized as idioms by at least clang 5.0+
 */
#define B(x)		((int32_t)(int8_t) ((&(x))[0]))

#define W(x)		((int32_t)(int16_t)(((unsigned) ((&(x))[0])     ) | \
				            ((unsigned) ((&(x))[1]) <<  8)))

#define L(x)		((int32_t)         ((uint32_t) ((&(x))[0])      ) | \
					   ((uint32_t) ((&(x))[1]) <<  8) | \
					   ((uint32_t) ((&(x))[2]) << 16) | \
					   ((uint32_t) ((&(x))[3]) << 24))



#endif

