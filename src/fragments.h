/* Copyright 2018  Peter Lund <firefly@vax64.dk>

   Licensed under GPL v2.

 */

#include <stdbool.h>

#include "vax-ucode.h"

/* fragment group tables

   The table is used by the simulator -- but it is also used by fragtable.c
   when it autogenerates a table that maps from opcodes to fragment lists.

   (it needs to look up the optype names for each fragment.)
 */

/* might as well use µcode labels directly, with a few exceptions:

   - (none)
   % ("reserved operand exception")
   addr (which is really many different classes)

   how about letting the autogenerated decoder return the correct addr µcode
   address?

   Using FRAG_NONE=0 makes the fragment_group[] table easier to read because
   unused entries can just be left out, or written as a discreet litlle '0'.
 */

#define FRAG_ERR	-1
#define FRAG_ADDR	-2
#define FRAG_NONE	 0	/* the code expects it to be 0 */

/* only used to make the table definition easier to read */
#define FRAG_PRE	 0
#define FRAG_POST	 1

struct fragment_desc {
	const char	*name; /* 'rb/rw/wl', 'ab/aw/al/aq', ... */
	bool		 isbranch;
	int		 frags[2][4]; /* [pre/post][I/R/M1M2] */
};

struct fragment_desc fragment_group[] = {
		   /* I          R               M                         */
{.name="rb/rw/rl/rf",
 .frags[FRAG_PRE ] = {LBL_IMM,   LBL_REGREAD,    FRAG_ADDR, LBL_MEMREAD},
 .frags[FRAG_POST] = {}},

		   /* I          R               M                         */
{.name="rq/rd/rg",
 .frags[FRAG_PRE ] = {LBL_IMM2,  LBL_REGREAD2,   FRAG_ADDR, LBL_MEMREAD2},
 .frags[FRAG_POST] = {}},

		   /* I          R               M                         */
{.name="mb/mw/ml/mf",
 .frags[FRAG_PRE ] = {FRAG_ERR,  LBL_REGREAD,    FRAG_ADDR, LBL_MEMREAD},
 .frags[FRAG_POST] = {0,         LBL_REGWRITE,   LBL_MEMWRITE          }},

		   /* I          R               M                         */
{.name="mi",
 .frags[FRAG_PRE ] = {FRAG_ERR,  LBL_REGREAD,    FRAG_ADDR, LBL_MEMREADI},
 .frags[FRAG_POST] = {0,         LBL_REGWRITE,   LBL_MEMWRITEI         }},

		   /* I          R               M                         */
{.name="mq/md/mg",
 .frags[FRAG_PRE ] = {FRAG_ERR,  LBL_REGREAD2,   FRAG_ADDR, LBL_MEMREAD2},
 .frags[FRAG_POST] = {0,         LBL_REGWRITE2,  LBL_MEMWRITE2         }},

		   /* I          R               M                         */
{.name="wb/ww/wl/wf",
 .frags[FRAG_PRE ] = {FRAG_ERR,  0,              FRAG_ADDR             },
 .frags[FRAG_POST] = {0,         LBL_REGWRITE,   LBL_MEMWRITE          }},

		   /* I          R               M                         */
{.name="wq/wd/wg",
 .frags[FRAG_PRE ] = {FRAG_ERR,  0,              FRAG_ADDR             },
 .frags[FRAG_POST] = {0,         LBL_REGWRITE2,  LBL_MEMWRITE2         }},

		   /* I          R               M                         */
{.name="ab/aw/al/aq",
 .frags[FRAG_PRE ] = {FRAG_ERR,   FRAG_ERR,      FRAG_ADDR             },
 .frags[FRAG_POST] = {}},

		   /* I          R               M                         */
{.name="vr",
 .frags[FRAG_PRE ] = {LBL_IMM,   LBL_VREGREAD,   FRAG_ADDR, LBL_VMEMREAD},
 .frags[FRAG_POST] = {}},

		   /* I          R               M                         */
{.name="vm",
 .frags[FRAG_PRE ] = {LBL_IMM,   LBL_VREGREAD,   FRAG_ADDR, LBL_VMEMREAD},
 .frags[FRAG_POST] = {0,         LBL_VREGWRITE,  LBL_VMEMWRITE          }},

		   /* I          R               M                         */
{.name="v1",
 .frags[FRAG_PRE ] = {LBL_IMM,   LBL_V1REGREAD,  FRAG_ADDR, LBL_V1MEMREAD},
 .frags[FRAG_POST] = {}},

		   /* I          R               M                         */
{.name="vi",
 .frags[FRAG_PRE ] = {LBL_IMM,   LBL_V1REGREAD,  FRAG_ADDR, LBL_V1MEMREADI},
 .frags[FRAG_POST] = {0,         LBL_V1REGWRITE, LBL_V1MEMWRITEI          }},

		   /* I          R               M                         */
{.name="bb/bw",
 .isbranch = true},
};


