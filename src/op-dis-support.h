/* Copyright 2018  Peter Lund <firefly@vax64.dk>

   Licensed under GPL v2.

   ---

   operand handling support code -- operand disassembly

   called by autogenerated code for dis.

 */

#ifndef OP_DIS_SUPPORT__H
#define OP_DIS_SUPPORT__H

#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "macros.h"
#include "strret.h"

#include "big-int.h"

#include "parse.h"

#include "fp.h"

#include "op-support.h"

/* expand_lit6() */
#include "op-lit6.h"

/***/


/* immediate -- 1/2/4/8/16 bytes, may be b/w/l/q/o int or f/d/g/h fp */
static struct str_ret str_imm(struct big_int imm, uint32_t pc, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) pc;

	switch (ifp) {
	case IFP_INT: if (width == 1) sprintf(buf.str, "0x%02X", imm.val[0] & 0xFF);
		 else if (width == 2) sprintf(buf.str, "0x%04X", imm.val[0] & 0xFFFF);
		 else if (width == 4) sprintf(buf.str, "0x%04X_%04X", SPLIT(imm.val[0]));
		 else if (width == 8) {
				      sprintf(buf.str, "0x%04X_%04X_%04X_%04X",
				      		SPLIT(imm.val[1]), SPLIT(imm.val[0]));
		 }
		 else if (width ==16) {
				      sprintf(buf.str, "0x%04X_%04X_%04X_%04X__%04X_%04X_%04X_%04X",
				      		SPLIT(imm.val[3]), SPLIT(imm.val[2]), SPLIT(imm.val[1]), SPLIT(imm.val[0]));
		 }
		 else UNREACHABLE();
		 break;
	case IFP_F: assert(width== 4); return fp_to_str("%g", imm, 'f');
	case IFP_D: assert(width== 8); return fp_to_str("%g", imm, 'd');
	case IFP_G: assert(width== 8); return fp_to_str("%g", imm, 'g');
	case IFP_H: assert(width==16); return fp_to_str("%g", imm, 'h');
	default:
		UNREACHABLE();
	}
	return buf;
}


/* register name (r0, r5, pc, ...) */
static struct str_ret str_reg(int reg, uint32_t pc, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) pc, (void) width, (void) ifp;

	assert((reg >= 0) && (reg <= 15));

	/* look for first matching register name */
	for (unsigned i=0; i < ARRAY_SIZE(regs); i++) {
		if (reg == regs[i].no) {
			strcpy(buf.str, regs[i].name);
			return buf;
		}
	}

	/* no match ?! */
	UNREACHABLE();
}


/* displacement relative to a register (that isn't PC) */
static struct str_ret str_disp(int32_t disp, uint32_t pc, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) pc, (void) width, (void) ifp;

	sprintf(buf.str, "%d", disp);
	return buf;
}


/* PC-relative address */
static struct str_ret str_pcrel(int32_t disp, uint32_t pc, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) width, (void) ifp;

	sprintf(buf.str, "0x%04X_%04X", SPLIT(disp + (uint32_t) pc));
	return buf;
}


/* absolute address */
static struct str_ret str_addr(int32_t addr, uint32_t pc, int width, enum ifp ifp)
{
	struct str_ret	buf;

	(void) pc, (void) width, (void) ifp;

	sprintf(buf.str, "0x%04X_%04X", SPLIT(addr));
	return buf;
}


#endif

